var RandomBackgroundGenerator =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	/*jshint esversion: 6 */
	
	/*
	 *	Random Canvas Background Generator
	 *
	 *	It's used on HTML Canvas to generate random background in a certain pattern
	 *	with certain customized parameters and modes. The background
	 * 	will update every time you click it.
	 *
	 */
	
	//-------------------------------
	//	Dependencies
	//-------------------------------
	var utils = __webpack_require__(1);
	var colorUtils = __webpack_require__(3);
	var Vector = __webpack_require__(2);
	
	/*
	*	Constant string name
	*/
	const POLYGONAL = "Polygonal";
	
	/*
	* Constructor
	*
	* @param {string} mode: The pattern in which the background is generated.
	*						 Currently Support: 1. "Polygonal"
	* @param {string} canvasId: The id of the canvas you want to generate background on
	*/
	function RandomBackgroundGenerator(canvasId, mode) {
		//	Initialize
		this._mode = mode || POLYGONAL;
		this._canvas = document.getElementById(canvasId);
		if (this._canvas !== null) {
		    this._canvasContext = this._canvas.getContext('2d');
		}
	}
	
	/*
	 *	Private helper function used to draw polygon on the canvas
	 *
	 *	@param {string} color: A HEX, RGB or RGBA color in the form of
	 *						   "#000000", "rgb(0, 0, 0)" or "rgba(0, 0, 0, 1)"
	 *	@param {Array} points: An array of Point objects
	 *	@param {boolean} gradient: A flag indicating if linear-gradient is enabled.
	 *							   The gradient will be randomly generated.
	 *
	 */
	RandomBackgroundGenerator.prototype._fillPolygon = function(color, polygon, gradient) {
		gradient = gradient || false;
	
		//	Save the previous states
		this._canvasContext.save();
	
		//---------------------------
		//	Set the color
		//---------------------------
		if (gradient) {
			if (polygon.points.length === 3) {
				let randomIntensity = Math.random();
				let gradColors = colorUtils.randomGradient(randomColor(color), randomIntensity);
	
				let startPoint = polygon.points[utils.getRandomNumberFromRange(0, polygon.points.length)];
				let endPoint;
	
				let index = polygon.points.indexOf(startPoint);
				let line = [];
				for (let i = 0; i < polygon.points.length; i++)
					if (i !== index) line.push(polygon.points[i]);
	
				let axis = new Vector(line[0].x - line[1].x, line[0].y - line[1].y);
				endPoint = startPoint.project(axis);
	
				let grad = this._canvasContext.createLinearGradient(
					startPoint.x, startPoint.y, endPoint.x, endPoint.y);
	
				this._canvasContext.fillStyle = grad;
			}
			else {
				this._canvasContext.fillStyle = color;
			}
		}
		else {
			this._canvasContext.fillStyle = color;
		}
	
		//-----------------------------------
		//	Draw the polygon
		//-----------------------------------
		this._canvasContext.beginPath();
		var points = polygon.getPoints();
		for (var i = 0; i < points.length; i++) {
			if (i === 0) {
				this._canvasContext.moveTo(points[i].x, points[i].y);
			} else {
				this._canvasContext.lineTo(points[i].x, points[i].y);
			}
		}
		this._canvasContext.closePath();
		this._canvasContext.fill();
	
		//	Restore previous states
		this._canvasContext.restore();
	};
	
	module.exports = RandomBackgroundGenerator;


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	var Vector = __webpack_require__(2);
	
	/*
	 *	Polygon class
	 */
	function Polygon(points) {
	    this._points = points || [];
	}
	Polygon.prototype = {
	    get points() {
	        return this._points;
	    },
	
	    set points(points) {
	        this._points = points;
	    }
	};
	
	/*
	 *  Clamp a number within a range
	 */
	function clamp(x, lower, upper){
	    return x < lower ? lower : x > upper ? upper : x;
	}
	
	/*
	 *	Get a random number from a range
	 *
	 *	@return {int / float} A randomly generated number within a range
	 *	@param {int / float} lower: The lower bound of the range(Inclusive)
	 *	@param {int / float} upper: The upper bound of the range(Exclusive)
	 *	@param {boolean} isInt: The flag to specify whether the result is int or float
	 */
	 function getRandomNumberFromRange(lower, upper, isInt) {
	     isInt = isInt || true;
	    //--------------------------------------------------
	    //	Some random numbers just coming out of nowhere
	    //--------------------------------------------------
	    var someRandomNumber1 = 1285,
	        someRandomNumber2 = 2391;
	
	    //	Generate the integer part
	    var randomInt =
	        parseInt(Math.random() * someRandomNumber1 * Math.random() * someRandomNumber2) % (upper - lower);
	
	    if (isInt) {
	        return lower + randomInt;
	    } else {
	        return lower + randomInt + Math.random();
	    }
	}
	
	/*
	 *  Get a random point on a rectangle
	 *
	 *	@param {Vector} p1, p2, p3, p4: Points of a rectangle starting
	 *								   from the top left corner and going
	 *								   clockwise.
	 */
	function getRandomPointOnRect(p1, p2, p3, p4) {
	    var width = Math.abs(p2.x - p1.x),
	        height = Math.abs(p3.y - p2.y),
	        topLeftX = Math.min(p1.x, p2.x, p3.x, p4.x),
	        topLeftY = Math.min(p1.y, p2.y, p3.y, p4.y);
	
	    var randomDeltaX = getRandomNumberFromRange(0, width, false),
	        randomDeltaY = getRandomNumberFromRange(0, height, false);
	
	    return new Vector(topLeftX + randomDeltaX, topLeftY + randomDeltaY);
	}
	
	/*
	 *  Get a random point on a line
	 *  @param {Vector} p1, p2: Points of a line from left to right
	 */
	function getRandomPointOnLine(p1, p2) {
	    var projectionWidth = Math.abs(p1.x - p2.x),
	        leftX = Math.min(p1.x, p2.x);
	
	    var A = (p1.y - p2.y) / (p1.x - p2.x),
	        B = p1.y - A * p1.x;
	
	    var randomDeltaX = getRandomNumberFromRange(0, projectionWidth, false);
	    return new Vector(leftX + randomDeltaX, A * (leftX + randomDeltaX) + B);
	}
	
	//  Exports
	module.exports.Polygon = Polygon;
	module.exports.clamp = clamp;
	module.exports.getRandomNumberFromRange = getRandomNumberFromRange;
	module.exports.getRandomPointOnRect = getRandomPointOnRect;
	module.exports.getRandomPointOnLine = getRandomPointOnLine;


/***/ },
/* 2 */
/***/ function(module, exports) {

	/*
	 *
	 *
	 *
	 *              Vector Class
	 *
	 *      Vector and vector operations.
	 *
	 *
	 *
	 */
	
	/*
	 *  Constructor
	 */
	function Vector(x, y){
		this.x = x || 0;
		this.y = y || 0;
	}
	
	Vector.prototype.dot = function(v){
		return this.x * v.x + this.y * v.y;
	};
	
	Vector.prototype.len2 = function(){
		return this.dot(this);
	};
	
	Vector.prototype.len = function(){
		return Math.sqrt(this.len2());
	};
	
	Vector.prototype.scale = function(sx, sy){
		this.x *= sx;
		this.y *= sy || sx;
		return this;
	};
	
	Vector.prototype.sub = function(v){
		this.x -= v.x;
		this.y -= v.y;
		return this;
	};
	
	//-------------------------------
	//	No side effect and chaining
	//-------------------------------
	Vector.prototype.project = function(axis){
		var cof =  this.dot(axis) / axis.len2();
		return axis.scale(cof);
	};
	
	Vector.prototype.projectN = function(axis){
		var cof =  this.dot(axis);
		return axis.scale(cof);
	};
	
	module.exports = Vector;


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	var utils = __webpack_require__(1);
	
	/*
	 *  Check if a string is in a hex color format
	 *  @return {boolean} True if the string is in a hex format
	 *  @param {string} color: The string representing the color
	 */
	function isHex(color) {
	    return /#[a-f0-9]{6}/gi.test(color);
	}
	
	/*
	 *  Check if a string is in a rgb color format
	 *  @return {boolean} True if the string is in a rgb format
	 *  @param {string} color: The string representing the color
	 */
	 function isRgb(color) {
	    //  Eliminate white spaces
	    color = color.replace(/\s/g, "");
	    return /rgb\([0-2]{0,1}[0-5]{0,1}[0-5]{1}\,[0-2]{0,1}[0-5]{0,1}[0-5]{1}\,[0-2]{0,1}[0-5]{0,1}[0-5]{1}\)/i.test(color);
	}
	 /*
	*  Check if a string is in a rgba color format
	*  @return {boolean} True if the string is in a rgba format
	*  @param {string} color: The string representing the color
	*/
	function isRgba(color) {
	 //  Eliminate white spaces
	 color = color.replace(/\s/g, "");
	 return /rgba\([0-2]{0,1}[0-5]{0,1}[0-5]{1}\,[0-2]{0,1}[0-5]{0,1}[0-5]{1}\,[0-2]{0,1}[0-5]{0,1}[0-5]{1}\,[0]{0,1}[.]{0,1}[0-9]{1,2}\)/i.test(color);
	
	}
	
	/*
	 *	Convert hex color to rgb color
	 *  @return {string / null} Converted color string or null if the input is invalid
	 */
	function hexToRgb(hex) {
	    if (isHex(hex)) {
	        return "rgb(" +
	        parseInt(hex.substr(1, 2), 16) + ", " +
	        parseInt(hex.substr(3, 2), 16) + ", " +
	        parseInt(hex.substr(5, 2), 16) + ")";
	    }
	    else return isRgb(hex) || isRgba(hex) ? hex : null;
	}
	
	/*
	 *	Adjust the brightness of a color by percentage
	 *  @param {string} color: The color string
	 *  @param {float} percentage: A float within [-1, 1] by which the brightness is adjusted.
	 *							   1 means maximum darkness and -1 means maximum brightness.
	 */
	function adjustColorBrightness(color, percentage) {
	    percentage = percentage || 0;
	    color = hexToRgb(color);
	
	    if (color !== null) {
	        //-------------------------------------------
	        //	Use different regex and formats for rgb and rgba
	        //-------------------------------------------
	        var regx = isRgb(color) ?
	            /[0-2]{0,1}[0-5]{0,1}[0-5]{1}/gi : /[0-2]{0,1}[0-5]{0,1}[0-5]{1}\,/gi;
	        var postfix = isRgb(color) ? '' : ',';
	
	        //	Math 'n,' in order to exclude the alpha
	        return color.replace(regx, function(e){
	            return utils.clamp((parseInt(e) * (1 - percentage)), 0, 255).toString() + postfix;
	        });
	    }
	
	    return null;
	}
	
	/*
	 *  Function to generate random color with random brightness
	 *  based on a given color
	 *
	 *	@return {string} A string of generated color
	 *  @param {string} baseColor: A color string in HEX, RGB or RGBA
	 *	@param {float} brightnessIntensity(Optional): The brightness intensity within [0, 1] to generate
	 *												  around. 0 means generate around 0 brightness changes,
	 *												  0.5 means generate around 50% brightness changes and
	 *												  1 means generate around maximum brightness changes.
	 *												  The brightness changes will be either drakening or brightening.
	 */
	 function randomColor(baseColor, brightnessIntensity){
	     brightnessIntensity = brightnessIntensity || 0.5;
	     var threshold = 0.2,
	         rangeLower = utils.clamp(brightnessIntensity - threshold, 0, 1),
	         rangeUpper = utils.clamp(brightnessIntensity + threshold, 0, 1);
	
	     //	Used to get a either negative or positive random number
	     var randomArr = [
	         utils.getRandomNumberFromRange(rangeLower, rangeUpper, false),
	         utils.getRandomNumberFromRange(-rangeLower, -rangeUpper, false)];
	
	     //	Color validity checking in adjustColorBrightness
	     return adjustColorBrightness(baseColor, randomArr[utils.getRandomNumberFromRange(0, 2)]);
	 }
	
	/*
	 *  Function to generate random gradient color with random brightness on both sides
	 *  of the linear gradient based on a given color
	 *
	 *	@return {Object} An object containing the pair of colors
	 *  @param {string} baseColor: A color string in HEX, RGB or RGBA
	 *	@param {float} brightnessIntensity(Optional): The brightness intensity within [0, 1] to generate
	 *												  around. The same as the one in randomColor
	 */
	 function randomGradient(baseColor, brightnessIntensity) {
	     brightnessIntensity = brightnessIntensity || 0.5;
	     return {
	         first: randomColor(baseColor, brightnessIntensity),
	         second: randomColor(baseColor, brightnessIntensity)
	     };
	 }
	
	//  Exports
	module.exports.isHex = isHex;
	module.exports.isRgb = isRgb;
	module.exports.isRgba = isRgba;
	module.exports.hexToRgb = hexToRgb;
	module.exports.adjustColorBrightness = adjustColorBrightness;
	module.exports.randomColor = randomColor;
	module.exports.randomGradient = randomGradient;


/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgYWYwOTRmMTE5MmQ5YzI3YmI2NTMiLCJ3ZWJwYWNrOi8vLy4vc3JjL1JhbmRvbUJhY2tncm91bmRHZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL3V0aWxzLmpzIiwid2VicGFjazovLy8uL3NyYy92ZWN0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbG9yVXRpbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1QkFBZTtBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7O0FDdENBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVUsT0FBTztBQUNqQjtBQUNBLFdBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBVyxPQUFPO0FBQ2xCO0FBQ0EsWUFBVyxNQUFNO0FBQ2pCLFlBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUJBQWtCLDJCQUEyQjtBQUM3Qzs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBZ0IsbUJBQW1C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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJSYW5kb21CYWNrZ3JvdW5kR2VuZXJhdG9yLm1pbi5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKVxuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuXG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRleHBvcnRzOiB7fSxcbiBcdFx0XHRpZDogbW9kdWxlSWQsXG4gXHRcdFx0bG9hZGVkOiBmYWxzZVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuXG5cblxuLyoqIFdFQlBBQ0sgRk9PVEVSICoqXG4gKiogd2VicGFjay9ib290c3RyYXAgYWYwOTRmMTE5MmQ5YzI3YmI2NTNcbiAqKi8iLCIvKmpzaGludCBlc3ZlcnNpb246IDYgKi9cclxuXHJcbi8qXHJcbiAqXHRSYW5kb20gQ2FudmFzIEJhY2tncm91bmQgR2VuZXJhdG9yXHJcbiAqXHJcbiAqXHRJdCdzIHVzZWQgb24gSFRNTCBDYW52YXMgdG8gZ2VuZXJhdGUgcmFuZG9tIGJhY2tncm91bmQgaW4gYSBjZXJ0YWluIHBhdHRlcm5cclxuICpcdHdpdGggY2VydGFpbiBjdXN0b21pemVkIHBhcmFtZXRlcnMgYW5kIG1vZGVzLiBUaGUgYmFja2dyb3VuZFxyXG4gKiBcdHdpbGwgdXBkYXRlIGV2ZXJ5IHRpbWUgeW91IGNsaWNrIGl0LlxyXG4gKlxyXG4gKi9cclxuXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4vL1x0RGVwZW5kZW5jaWVzXHJcbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XHJcbnZhciBjb2xvclV0aWxzID0gcmVxdWlyZSgnLi9jb2xvclV0aWxzJyk7XHJcbnZhciBWZWN0b3IgPSByZXF1aXJlKCcuL3ZlY3RvcicpO1xyXG5cclxuLypcclxuKlx0Q29uc3RhbnQgc3RyaW5nIG5hbWVcclxuKi9cclxuY29uc3QgUE9MWUdPTkFMID0gXCJQb2x5Z29uYWxcIjtcclxuXHJcbi8qXHJcbiogQ29uc3RydWN0b3JcclxuKlxyXG4qIEBwYXJhbSB7c3RyaW5nfSBtb2RlOiBUaGUgcGF0dGVybiBpbiB3aGljaCB0aGUgYmFja2dyb3VuZCBpcyBnZW5lcmF0ZWQuXHJcbipcdFx0XHRcdFx0XHQgQ3VycmVudGx5IFN1cHBvcnQ6IDEuIFwiUG9seWdvbmFsXCJcclxuKiBAcGFyYW0ge3N0cmluZ30gY2FudmFzSWQ6IFRoZSBpZCBvZiB0aGUgY2FudmFzIHlvdSB3YW50IHRvIGdlbmVyYXRlIGJhY2tncm91bmQgb25cclxuKi9cclxuZnVuY3Rpb24gUmFuZG9tQmFja2dyb3VuZEdlbmVyYXRvcihjYW52YXNJZCwgbW9kZSkge1xyXG5cdC8vXHRJbml0aWFsaXplXHJcblx0dGhpcy5fbW9kZSA9IG1vZGUgfHwgUE9MWUdPTkFMO1xyXG5cdHRoaXMuX2NhbnZhcyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNhbnZhc0lkKTtcclxuXHRpZiAodGhpcy5fY2FudmFzICE9PSBudWxsKSB7XHJcblx0ICAgIHRoaXMuX2NhbnZhc0NvbnRleHQgPSB0aGlzLl9jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcclxuXHR9XHJcbn1cclxuXHJcbi8qXHJcbiAqXHRQcml2YXRlIGhlbHBlciBmdW5jdGlvbiB1c2VkIHRvIGRyYXcgcG9seWdvbiBvbiB0aGUgY2FudmFzXHJcbiAqXHJcbiAqXHRAcGFyYW0ge3N0cmluZ30gY29sb3I6IEEgSEVYLCBSR0Igb3IgUkdCQSBjb2xvciBpbiB0aGUgZm9ybSBvZlxyXG4gKlx0XHRcdFx0XHRcdCAgIFwiIzAwMDAwMFwiLCBcInJnYigwLCAwLCAwKVwiIG9yIFwicmdiYSgwLCAwLCAwLCAxKVwiXHJcbiAqXHRAcGFyYW0ge0FycmF5fSBwb2ludHM6IEFuIGFycmF5IG9mIFBvaW50IG9iamVjdHNcclxuICpcdEBwYXJhbSB7Ym9vbGVhbn0gZ3JhZGllbnQ6IEEgZmxhZyBpbmRpY2F0aW5nIGlmIGxpbmVhci1ncmFkaWVudCBpcyBlbmFibGVkLlxyXG4gKlx0XHRcdFx0XHRcdFx0ICAgVGhlIGdyYWRpZW50IHdpbGwgYmUgcmFuZG9tbHkgZ2VuZXJhdGVkLlxyXG4gKlxyXG4gKi9cclxuUmFuZG9tQmFja2dyb3VuZEdlbmVyYXRvci5wcm90b3R5cGUuX2ZpbGxQb2x5Z29uID0gZnVuY3Rpb24oY29sb3IsIHBvbHlnb24sIGdyYWRpZW50KSB7XHJcblx0Z3JhZGllbnQgPSBncmFkaWVudCB8fCBmYWxzZTtcclxuXHJcblx0Ly9cdFNhdmUgdGhlIHByZXZpb3VzIHN0YXRlc1xyXG5cdHRoaXMuX2NhbnZhc0NvbnRleHQuc2F2ZSgpO1xyXG5cclxuXHQvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cdC8vXHRTZXQgdGhlIGNvbG9yXHJcblx0Ly8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuXHRpZiAoZ3JhZGllbnQpIHtcclxuXHRcdGlmIChwb2x5Z29uLnBvaW50cy5sZW5ndGggPT09IDMpIHtcclxuXHRcdFx0bGV0IHJhbmRvbUludGVuc2l0eSA9IE1hdGgucmFuZG9tKCk7XHJcblx0XHRcdGxldCBncmFkQ29sb3JzID0gY29sb3JVdGlscy5yYW5kb21HcmFkaWVudChyYW5kb21Db2xvcihjb2xvciksIHJhbmRvbUludGVuc2l0eSk7XHJcblxyXG5cdFx0XHRsZXQgc3RhcnRQb2ludCA9IHBvbHlnb24ucG9pbnRzW3V0aWxzLmdldFJhbmRvbU51bWJlckZyb21SYW5nZSgwLCBwb2x5Z29uLnBvaW50cy5sZW5ndGgpXTtcclxuXHRcdFx0bGV0IGVuZFBvaW50O1xyXG5cclxuXHRcdFx0bGV0IGluZGV4ID0gcG9seWdvbi5wb2ludHMuaW5kZXhPZihzdGFydFBvaW50KTtcclxuXHRcdFx0bGV0IGxpbmUgPSBbXTtcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwb2x5Z29uLnBvaW50cy5sZW5ndGg7IGkrKylcclxuXHRcdFx0XHRpZiAoaSAhPT0gaW5kZXgpIGxpbmUucHVzaChwb2x5Z29uLnBvaW50c1tpXSk7XHJcblxyXG5cdFx0XHRsZXQgYXhpcyA9IG5ldyBWZWN0b3IobGluZVswXS54IC0gbGluZVsxXS54LCBsaW5lWzBdLnkgLSBsaW5lWzFdLnkpO1xyXG5cdFx0XHRlbmRQb2ludCA9IHN0YXJ0UG9pbnQucHJvamVjdChheGlzKTtcclxuXHJcblx0XHRcdGxldCBncmFkID0gdGhpcy5fY2FudmFzQ29udGV4dC5jcmVhdGVMaW5lYXJHcmFkaWVudChcclxuXHRcdFx0XHRzdGFydFBvaW50LngsIHN0YXJ0UG9pbnQueSwgZW5kUG9pbnQueCwgZW5kUG9pbnQueSk7XHJcblxyXG5cdFx0XHR0aGlzLl9jYW52YXNDb250ZXh0LmZpbGxTdHlsZSA9IGdyYWQ7XHJcblx0XHR9XHJcblx0XHRlbHNlIHtcclxuXHRcdFx0dGhpcy5fY2FudmFzQ29udGV4dC5maWxsU3R5bGUgPSBjb2xvcjtcclxuXHRcdH1cclxuXHR9XHJcblx0ZWxzZSB7XHJcblx0XHR0aGlzLl9jYW52YXNDb250ZXh0LmZpbGxTdHlsZSA9IGNvbG9yO1xyXG5cdH1cclxuXHJcblx0Ly8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cdC8vXHREcmF3IHRoZSBwb2x5Z29uXHJcblx0Ly8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG5cdHRoaXMuX2NhbnZhc0NvbnRleHQuYmVnaW5QYXRoKCk7XHJcblx0dmFyIHBvaW50cyA9IHBvbHlnb24uZ2V0UG9pbnRzKCk7XHJcblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChpID09PSAwKSB7XHJcblx0XHRcdHRoaXMuX2NhbnZhc0NvbnRleHQubW92ZVRvKHBvaW50c1tpXS54LCBwb2ludHNbaV0ueSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9jYW52YXNDb250ZXh0LmxpbmVUbyhwb2ludHNbaV0ueCwgcG9pbnRzW2ldLnkpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHR0aGlzLl9jYW52YXNDb250ZXh0LmNsb3NlUGF0aCgpO1xyXG5cdHRoaXMuX2NhbnZhc0NvbnRleHQuZmlsbCgpO1xyXG5cclxuXHQvL1x0UmVzdG9yZSBwcmV2aW91cyBzdGF0ZXNcclxuXHR0aGlzLl9jYW52YXNDb250ZXh0LnJlc3RvcmUoKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gUmFuZG9tQmFja2dyb3VuZEdlbmVyYXRvcjtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy9SYW5kb21CYWNrZ3JvdW5kR2VuZXJhdG9yLmpzXG4gKiogbW9kdWxlIGlkID0gMFxuICoqIG1vZHVsZSBjaHVua3MgPSAwXG4gKiovIiwidmFyIFZlY3RvciA9IHJlcXVpcmUoJy4vdmVjdG9yJyk7XHJcblxyXG4vKlxyXG4gKlx0UG9seWdvbiBjbGFzc1xyXG4gKi9cclxuZnVuY3Rpb24gUG9seWdvbihwb2ludHMpIHtcclxuICAgIHRoaXMuX3BvaW50cyA9IHBvaW50cyB8fCBbXTtcclxufVxyXG5Qb2x5Z29uLnByb3RvdHlwZSA9IHtcclxuICAgIGdldCBwb2ludHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BvaW50cztcclxuICAgIH0sXHJcblxyXG4gICAgc2V0IHBvaW50cyhwb2ludHMpIHtcclxuICAgICAgICB0aGlzLl9wb2ludHMgPSBwb2ludHM7XHJcbiAgICB9XHJcbn07XHJcblxyXG4vKlxyXG4gKiAgQ2xhbXAgYSBudW1iZXIgd2l0aGluIGEgcmFuZ2VcclxuICovXHJcbmZ1bmN0aW9uIGNsYW1wKHgsIGxvd2VyLCB1cHBlcil7XHJcbiAgICByZXR1cm4geCA8IGxvd2VyID8gbG93ZXIgOiB4ID4gdXBwZXIgPyB1cHBlciA6IHg7XHJcbn1cclxuXHJcbi8qXHJcbiAqXHRHZXQgYSByYW5kb20gbnVtYmVyIGZyb20gYSByYW5nZVxyXG4gKlxyXG4gKlx0QHJldHVybiB7aW50IC8gZmxvYXR9IEEgcmFuZG9tbHkgZ2VuZXJhdGVkIG51bWJlciB3aXRoaW4gYSByYW5nZVxyXG4gKlx0QHBhcmFtIHtpbnQgLyBmbG9hdH0gbG93ZXI6IFRoZSBsb3dlciBib3VuZCBvZiB0aGUgcmFuZ2UoSW5jbHVzaXZlKVxyXG4gKlx0QHBhcmFtIHtpbnQgLyBmbG9hdH0gdXBwZXI6IFRoZSB1cHBlciBib3VuZCBvZiB0aGUgcmFuZ2UoRXhjbHVzaXZlKVxyXG4gKlx0QHBhcmFtIHtib29sZWFufSBpc0ludDogVGhlIGZsYWcgdG8gc3BlY2lmeSB3aGV0aGVyIHRoZSByZXN1bHQgaXMgaW50IG9yIGZsb2F0XHJcbiAqL1xyXG4gZnVuY3Rpb24gZ2V0UmFuZG9tTnVtYmVyRnJvbVJhbmdlKGxvd2VyLCB1cHBlciwgaXNJbnQpIHtcclxuICAgICBpc0ludCA9IGlzSW50IHx8IHRydWU7XHJcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAvL1x0U29tZSByYW5kb20gbnVtYmVycyBqdXN0IGNvbWluZyBvdXQgb2Ygbm93aGVyZVxyXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgdmFyIHNvbWVSYW5kb21OdW1iZXIxID0gMTI4NSxcclxuICAgICAgICBzb21lUmFuZG9tTnVtYmVyMiA9IDIzOTE7XHJcblxyXG4gICAgLy9cdEdlbmVyYXRlIHRoZSBpbnRlZ2VyIHBhcnRcclxuICAgIHZhciByYW5kb21JbnQgPVxyXG4gICAgICAgIHBhcnNlSW50KE1hdGgucmFuZG9tKCkgKiBzb21lUmFuZG9tTnVtYmVyMSAqIE1hdGgucmFuZG9tKCkgKiBzb21lUmFuZG9tTnVtYmVyMikgJSAodXBwZXIgLSBsb3dlcik7XHJcblxyXG4gICAgaWYgKGlzSW50KSB7XHJcbiAgICAgICAgcmV0dXJuIGxvd2VyICsgcmFuZG9tSW50O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICByZXR1cm4gbG93ZXIgKyByYW5kb21JbnQgKyBNYXRoLnJhbmRvbSgpO1xyXG4gICAgfVxyXG59XHJcblxyXG4vKlxyXG4gKiAgR2V0IGEgcmFuZG9tIHBvaW50IG9uIGEgcmVjdGFuZ2xlXHJcbiAqXHJcbiAqXHRAcGFyYW0ge1ZlY3Rvcn0gcDEsIHAyLCBwMywgcDQ6IFBvaW50cyBvZiBhIHJlY3RhbmdsZSBzdGFydGluZ1xyXG4gKlx0XHRcdFx0XHRcdFx0XHQgICBmcm9tIHRoZSB0b3AgbGVmdCBjb3JuZXIgYW5kIGdvaW5nXHJcbiAqXHRcdFx0XHRcdFx0XHRcdCAgIGNsb2Nrd2lzZS5cclxuICovXHJcbmZ1bmN0aW9uIGdldFJhbmRvbVBvaW50T25SZWN0KHAxLCBwMiwgcDMsIHA0KSB7XHJcbiAgICB2YXIgd2lkdGggPSBNYXRoLmFicyhwMi54IC0gcDEueCksXHJcbiAgICAgICAgaGVpZ2h0ID0gTWF0aC5hYnMocDMueSAtIHAyLnkpLFxyXG4gICAgICAgIHRvcExlZnRYID0gTWF0aC5taW4ocDEueCwgcDIueCwgcDMueCwgcDQueCksXHJcbiAgICAgICAgdG9wTGVmdFkgPSBNYXRoLm1pbihwMS55LCBwMi55LCBwMy55LCBwNC55KTtcclxuXHJcbiAgICB2YXIgcmFuZG9tRGVsdGFYID0gZ2V0UmFuZG9tTnVtYmVyRnJvbVJhbmdlKDAsIHdpZHRoLCBmYWxzZSksXHJcbiAgICAgICAgcmFuZG9tRGVsdGFZID0gZ2V0UmFuZG9tTnVtYmVyRnJvbVJhbmdlKDAsIGhlaWdodCwgZmFsc2UpO1xyXG5cclxuICAgIHJldHVybiBuZXcgVmVjdG9yKHRvcExlZnRYICsgcmFuZG9tRGVsdGFYLCB0b3BMZWZ0WSArIHJhbmRvbURlbHRhWSk7XHJcbn1cclxuXHJcbi8qXHJcbiAqICBHZXQgYSByYW5kb20gcG9pbnQgb24gYSBsaW5lXHJcbiAqICBAcGFyYW0ge1ZlY3Rvcn0gcDEsIHAyOiBQb2ludHMgb2YgYSBsaW5lIGZyb20gbGVmdCB0byByaWdodFxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UmFuZG9tUG9pbnRPbkxpbmUocDEsIHAyKSB7XHJcbiAgICB2YXIgcHJvamVjdGlvbldpZHRoID0gTWF0aC5hYnMocDEueCAtIHAyLngpLFxyXG4gICAgICAgIGxlZnRYID0gTWF0aC5taW4ocDEueCwgcDIueCk7XHJcblxyXG4gICAgdmFyIEEgPSAocDEueSAtIHAyLnkpIC8gKHAxLnggLSBwMi54KSxcclxuICAgICAgICBCID0gcDEueSAtIEEgKiBwMS54O1xyXG5cclxuICAgIHZhciByYW5kb21EZWx0YVggPSBnZXRSYW5kb21OdW1iZXJGcm9tUmFuZ2UoMCwgcHJvamVjdGlvbldpZHRoLCBmYWxzZSk7XHJcbiAgICByZXR1cm4gbmV3IFZlY3RvcihsZWZ0WCArIHJhbmRvbURlbHRhWCwgQSAqIChsZWZ0WCArIHJhbmRvbURlbHRhWCkgKyBCKTtcclxufVxyXG5cclxuLy8gIEV4cG9ydHNcclxubW9kdWxlLmV4cG9ydHMuUG9seWdvbiA9IFBvbHlnb247XHJcbm1vZHVsZS5leHBvcnRzLmNsYW1wID0gY2xhbXA7XHJcbm1vZHVsZS5leHBvcnRzLmdldFJhbmRvbU51bWJlckZyb21SYW5nZSA9IGdldFJhbmRvbU51bWJlckZyb21SYW5nZTtcclxubW9kdWxlLmV4cG9ydHMuZ2V0UmFuZG9tUG9pbnRPblJlY3QgPSBnZXRSYW5kb21Qb2ludE9uUmVjdDtcclxubW9kdWxlLmV4cG9ydHMuZ2V0UmFuZG9tUG9pbnRPbkxpbmUgPSBnZXRSYW5kb21Qb2ludE9uTGluZTtcclxuXG5cblxuLyoqKioqKioqKioqKioqKioqXG4gKiogV0VCUEFDSyBGT09URVJcbiAqKiAuL3NyYy91dGlscy5qc1xuICoqIG1vZHVsZSBpZCA9IDFcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsIi8qXHJcbiAqXHJcbiAqXHJcbiAqXHJcbiAqICAgICAgICAgICAgICBWZWN0b3IgQ2xhc3NcclxuICpcclxuICogICAgICBWZWN0b3IgYW5kIHZlY3RvciBvcGVyYXRpb25zLlxyXG4gKlxyXG4gKlxyXG4gKlxyXG4gKi9cclxuXHJcbi8qXHJcbiAqICBDb25zdHJ1Y3RvclxyXG4gKi9cclxuZnVuY3Rpb24gVmVjdG9yKHgsIHkpe1xyXG5cdHRoaXMueCA9IHggfHwgMDtcclxuXHR0aGlzLnkgPSB5IHx8IDA7XHJcbn1cclxuXHJcblZlY3Rvci5wcm90b3R5cGUuZG90ID0gZnVuY3Rpb24odil7XHJcblx0cmV0dXJuIHRoaXMueCAqIHYueCArIHRoaXMueSAqIHYueTtcclxufTtcclxuXHJcblZlY3Rvci5wcm90b3R5cGUubGVuMiA9IGZ1bmN0aW9uKCl7XHJcblx0cmV0dXJuIHRoaXMuZG90KHRoaXMpO1xyXG59O1xyXG5cclxuVmVjdG9yLnByb3RvdHlwZS5sZW4gPSBmdW5jdGlvbigpe1xyXG5cdHJldHVybiBNYXRoLnNxcnQodGhpcy5sZW4yKCkpO1xyXG59O1xyXG5cclxuVmVjdG9yLnByb3RvdHlwZS5zY2FsZSA9IGZ1bmN0aW9uKHN4LCBzeSl7XHJcblx0dGhpcy54ICo9IHN4O1xyXG5cdHRoaXMueSAqPSBzeSB8fCBzeDtcclxuXHRyZXR1cm4gdGhpcztcclxufTtcclxuXHJcblZlY3Rvci5wcm90b3R5cGUuc3ViID0gZnVuY3Rpb24odil7XHJcblx0dGhpcy54IC09IHYueDtcclxuXHR0aGlzLnkgLT0gdi55O1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbi8vXHRObyBzaWRlIGVmZmVjdCBhbmQgY2hhaW5pbmdcclxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcblZlY3Rvci5wcm90b3R5cGUucHJvamVjdCA9IGZ1bmN0aW9uKGF4aXMpe1xyXG5cdHZhciBjb2YgPSAgdGhpcy5kb3QoYXhpcykgLyBheGlzLmxlbjIoKTtcclxuXHRyZXR1cm4gYXhpcy5zY2FsZShjb2YpO1xyXG59O1xyXG5cclxuVmVjdG9yLnByb3RvdHlwZS5wcm9qZWN0TiA9IGZ1bmN0aW9uKGF4aXMpe1xyXG5cdHZhciBjb2YgPSAgdGhpcy5kb3QoYXhpcyk7XHJcblx0cmV0dXJuIGF4aXMuc2NhbGUoY29mKTtcclxufTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gVmVjdG9yO1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL3ZlY3Rvci5qc1xuICoqIG1vZHVsZSBpZCA9IDJcbiAqKiBtb2R1bGUgY2h1bmtzID0gMFxuICoqLyIsInZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcclxuXHJcbi8qXHJcbiAqICBDaGVjayBpZiBhIHN0cmluZyBpcyBpbiBhIGhleCBjb2xvciBmb3JtYXRcclxuICogIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHN0cmluZyBpcyBpbiBhIGhleCBmb3JtYXRcclxuICogIEBwYXJhbSB7c3RyaW5nfSBjb2xvcjogVGhlIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGNvbG9yXHJcbiAqL1xyXG5mdW5jdGlvbiBpc0hleChjb2xvcikge1xyXG4gICAgcmV0dXJuIC8jW2EtZjAtOV17Nn0vZ2kudGVzdChjb2xvcik7XHJcbn1cclxuXHJcbi8qXHJcbiAqICBDaGVjayBpZiBhIHN0cmluZyBpcyBpbiBhIHJnYiBjb2xvciBmb3JtYXRcclxuICogIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHN0cmluZyBpcyBpbiBhIHJnYiBmb3JtYXRcclxuICogIEBwYXJhbSB7c3RyaW5nfSBjb2xvcjogVGhlIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGNvbG9yXHJcbiAqL1xyXG4gZnVuY3Rpb24gaXNSZ2IoY29sb3IpIHtcclxuICAgIC8vICBFbGltaW5hdGUgd2hpdGUgc3BhY2VzXHJcbiAgICBjb2xvciA9IGNvbG9yLnJlcGxhY2UoL1xccy9nLCBcIlwiKTtcclxuICAgIHJldHVybiAvcmdiXFwoWzAtMl17MCwxfVswLTVdezAsMX1bMC01XXsxfVxcLFswLTJdezAsMX1bMC01XXswLDF9WzAtNV17MX1cXCxbMC0yXXswLDF9WzAtNV17MCwxfVswLTVdezF9XFwpL2kudGVzdChjb2xvcik7XHJcbn1cclxuIC8qXHJcbiogIENoZWNrIGlmIGEgc3RyaW5nIGlzIGluIGEgcmdiYSBjb2xvciBmb3JtYXRcclxuKiAgQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3RyaW5nIGlzIGluIGEgcmdiYSBmb3JtYXRcclxuKiAgQHBhcmFtIHtzdHJpbmd9IGNvbG9yOiBUaGUgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY29sb3JcclxuKi9cclxuZnVuY3Rpb24gaXNSZ2JhKGNvbG9yKSB7XHJcbiAvLyAgRWxpbWluYXRlIHdoaXRlIHNwYWNlc1xyXG4gY29sb3IgPSBjb2xvci5yZXBsYWNlKC9cXHMvZywgXCJcIik7XHJcbiByZXR1cm4gL3JnYmFcXChbMC0yXXswLDF9WzAtNV17MCwxfVswLTVdezF9XFwsWzAtMl17MCwxfVswLTVdezAsMX1bMC01XXsxfVxcLFswLTJdezAsMX1bMC01XXswLDF9WzAtNV17MX1cXCxbMF17MCwxfVsuXXswLDF9WzAtOV17MSwyfVxcKS9pLnRlc3QoY29sb3IpO1xyXG5cclxufVxyXG5cclxuLypcclxuICpcdENvbnZlcnQgaGV4IGNvbG9yIHRvIHJnYiBjb2xvclxyXG4gKiAgQHJldHVybiB7c3RyaW5nIC8gbnVsbH0gQ29udmVydGVkIGNvbG9yIHN0cmluZyBvciBudWxsIGlmIHRoZSBpbnB1dCBpcyBpbnZhbGlkXHJcbiAqL1xyXG5mdW5jdGlvbiBoZXhUb1JnYihoZXgpIHtcclxuICAgIGlmIChpc0hleChoZXgpKSB7XHJcbiAgICAgICAgcmV0dXJuIFwicmdiKFwiICtcclxuICAgICAgICBwYXJzZUludChoZXguc3Vic3RyKDEsIDIpLCAxNikgKyBcIiwgXCIgK1xyXG4gICAgICAgIHBhcnNlSW50KGhleC5zdWJzdHIoMywgMiksIDE2KSArIFwiLCBcIiArXHJcbiAgICAgICAgcGFyc2VJbnQoaGV4LnN1YnN0cig1LCAyKSwgMTYpICsgXCIpXCI7XHJcbiAgICB9XHJcbiAgICBlbHNlIHJldHVybiBpc1JnYihoZXgpIHx8IGlzUmdiYShoZXgpID8gaGV4IDogbnVsbDtcclxufVxyXG5cclxuLypcclxuICpcdEFkanVzdCB0aGUgYnJpZ2h0bmVzcyBvZiBhIGNvbG9yIGJ5IHBlcmNlbnRhZ2VcclxuICogIEBwYXJhbSB7c3RyaW5nfSBjb2xvcjogVGhlIGNvbG9yIHN0cmluZ1xyXG4gKiAgQHBhcmFtIHtmbG9hdH0gcGVyY2VudGFnZTogQSBmbG9hdCB3aXRoaW4gWy0xLCAxXSBieSB3aGljaCB0aGUgYnJpZ2h0bmVzcyBpcyBhZGp1c3RlZC5cclxuICpcdFx0XHRcdFx0XHRcdCAgIDEgbWVhbnMgbWF4aW11bSBkYXJrbmVzcyBhbmQgLTEgbWVhbnMgbWF4aW11bSBicmlnaHRuZXNzLlxyXG4gKi9cclxuZnVuY3Rpb24gYWRqdXN0Q29sb3JCcmlnaHRuZXNzKGNvbG9yLCBwZXJjZW50YWdlKSB7XHJcbiAgICBwZXJjZW50YWdlID0gcGVyY2VudGFnZSB8fCAwO1xyXG4gICAgY29sb3IgPSBoZXhUb1JnYihjb2xvcik7XHJcblxyXG4gICAgaWYgKGNvbG9yICE9PSBudWxsKSB7XHJcbiAgICAgICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICAgICAgLy9cdFVzZSBkaWZmZXJlbnQgcmVnZXggYW5kIGZvcm1hdHMgZm9yIHJnYiBhbmQgcmdiYVxyXG4gICAgICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAgICAgIHZhciByZWd4ID0gaXNSZ2IoY29sb3IpID9cclxuICAgICAgICAgICAgL1swLTJdezAsMX1bMC01XXswLDF9WzAtNV17MX0vZ2kgOiAvWzAtMl17MCwxfVswLTVdezAsMX1bMC01XXsxfVxcLC9naTtcclxuICAgICAgICB2YXIgcG9zdGZpeCA9IGlzUmdiKGNvbG9yKSA/ICcnIDogJywnO1xyXG5cclxuICAgICAgICAvL1x0TWF0aCAnbiwnIGluIG9yZGVyIHRvIGV4Y2x1ZGUgdGhlIGFscGhhXHJcbiAgICAgICAgcmV0dXJuIGNvbG9yLnJlcGxhY2UocmVneCwgZnVuY3Rpb24oZSl7XHJcbiAgICAgICAgICAgIHJldHVybiB1dGlscy5jbGFtcCgocGFyc2VJbnQoZSkgKiAoMSAtIHBlcmNlbnRhZ2UpKSwgMCwgMjU1KS50b1N0cmluZygpICsgcG9zdGZpeDtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5cclxuLypcclxuICogIEZ1bmN0aW9uIHRvIGdlbmVyYXRlIHJhbmRvbSBjb2xvciB3aXRoIHJhbmRvbSBicmlnaHRuZXNzXHJcbiAqICBiYXNlZCBvbiBhIGdpdmVuIGNvbG9yXHJcbiAqXHJcbiAqXHRAcmV0dXJuIHtzdHJpbmd9IEEgc3RyaW5nIG9mIGdlbmVyYXRlZCBjb2xvclxyXG4gKiAgQHBhcmFtIHtzdHJpbmd9IGJhc2VDb2xvcjogQSBjb2xvciBzdHJpbmcgaW4gSEVYLCBSR0Igb3IgUkdCQVxyXG4gKlx0QHBhcmFtIHtmbG9hdH0gYnJpZ2h0bmVzc0ludGVuc2l0eShPcHRpb25hbCk6IFRoZSBicmlnaHRuZXNzIGludGVuc2l0eSB3aXRoaW4gWzAsIDFdIHRvIGdlbmVyYXRlXHJcbiAqXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICBhcm91bmQuIDAgbWVhbnMgZ2VuZXJhdGUgYXJvdW5kIDAgYnJpZ2h0bmVzcyBjaGFuZ2VzLFxyXG4gKlx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgMC41IG1lYW5zIGdlbmVyYXRlIGFyb3VuZCA1MCUgYnJpZ2h0bmVzcyBjaGFuZ2VzIGFuZFxyXG4gKlx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAgMSBtZWFucyBnZW5lcmF0ZSBhcm91bmQgbWF4aW11bSBicmlnaHRuZXNzIGNoYW5nZXMuXHJcbiAqXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ICBUaGUgYnJpZ2h0bmVzcyBjaGFuZ2VzIHdpbGwgYmUgZWl0aGVyIGRyYWtlbmluZyBvciBicmlnaHRlbmluZy5cclxuICovXHJcbiBmdW5jdGlvbiByYW5kb21Db2xvcihiYXNlQ29sb3IsIGJyaWdodG5lc3NJbnRlbnNpdHkpe1xyXG4gICAgIGJyaWdodG5lc3NJbnRlbnNpdHkgPSBicmlnaHRuZXNzSW50ZW5zaXR5IHx8IDAuNTtcclxuICAgICB2YXIgdGhyZXNob2xkID0gMC4yLFxyXG4gICAgICAgICByYW5nZUxvd2VyID0gdXRpbHMuY2xhbXAoYnJpZ2h0bmVzc0ludGVuc2l0eSAtIHRocmVzaG9sZCwgMCwgMSksXHJcbiAgICAgICAgIHJhbmdlVXBwZXIgPSB1dGlscy5jbGFtcChicmlnaHRuZXNzSW50ZW5zaXR5ICsgdGhyZXNob2xkLCAwLCAxKTtcclxuXHJcbiAgICAgLy9cdFVzZWQgdG8gZ2V0IGEgZWl0aGVyIG5lZ2F0aXZlIG9yIHBvc2l0aXZlIHJhbmRvbSBudW1iZXJcclxuICAgICB2YXIgcmFuZG9tQXJyID0gW1xyXG4gICAgICAgICB1dGlscy5nZXRSYW5kb21OdW1iZXJGcm9tUmFuZ2UocmFuZ2VMb3dlciwgcmFuZ2VVcHBlciwgZmFsc2UpLFxyXG4gICAgICAgICB1dGlscy5nZXRSYW5kb21OdW1iZXJGcm9tUmFuZ2UoLXJhbmdlTG93ZXIsIC1yYW5nZVVwcGVyLCBmYWxzZSldO1xyXG5cclxuICAgICAvL1x0Q29sb3IgdmFsaWRpdHkgY2hlY2tpbmcgaW4gYWRqdXN0Q29sb3JCcmlnaHRuZXNzXHJcbiAgICAgcmV0dXJuIGFkanVzdENvbG9yQnJpZ2h0bmVzcyhiYXNlQ29sb3IsIHJhbmRvbUFyclt1dGlscy5nZXRSYW5kb21OdW1iZXJGcm9tUmFuZ2UoMCwgMildKTtcclxuIH1cclxuXHJcbi8qXHJcbiAqICBGdW5jdGlvbiB0byBnZW5lcmF0ZSByYW5kb20gZ3JhZGllbnQgY29sb3Igd2l0aCByYW5kb20gYnJpZ2h0bmVzcyBvbiBib3RoIHNpZGVzXHJcbiAqICBvZiB0aGUgbGluZWFyIGdyYWRpZW50IGJhc2VkIG9uIGEgZ2l2ZW4gY29sb3JcclxuICpcclxuICpcdEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhaXIgb2YgY29sb3JzXHJcbiAqICBAcGFyYW0ge3N0cmluZ30gYmFzZUNvbG9yOiBBIGNvbG9yIHN0cmluZyBpbiBIRVgsIFJHQiBvciBSR0JBXHJcbiAqXHRAcGFyYW0ge2Zsb2F0fSBicmlnaHRuZXNzSW50ZW5zaXR5KE9wdGlvbmFsKTogVGhlIGJyaWdodG5lc3MgaW50ZW5zaXR5IHdpdGhpbiBbMCwgMV0gdG8gZ2VuZXJhdGVcclxuICpcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQgIGFyb3VuZC4gVGhlIHNhbWUgYXMgdGhlIG9uZSBpbiByYW5kb21Db2xvclxyXG4gKi9cclxuIGZ1bmN0aW9uIHJhbmRvbUdyYWRpZW50KGJhc2VDb2xvciwgYnJpZ2h0bmVzc0ludGVuc2l0eSkge1xyXG4gICAgIGJyaWdodG5lc3NJbnRlbnNpdHkgPSBicmlnaHRuZXNzSW50ZW5zaXR5IHx8IDAuNTtcclxuICAgICByZXR1cm4ge1xyXG4gICAgICAgICBmaXJzdDogcmFuZG9tQ29sb3IoYmFzZUNvbG9yLCBicmlnaHRuZXNzSW50ZW5zaXR5KSxcclxuICAgICAgICAgc2Vjb25kOiByYW5kb21Db2xvcihiYXNlQ29sb3IsIGJyaWdodG5lc3NJbnRlbnNpdHkpXHJcbiAgICAgfTtcclxuIH1cclxuXHJcbi8vICBFeHBvcnRzXHJcbm1vZHVsZS5leHBvcnRzLmlzSGV4ID0gaXNIZXg7XHJcbm1vZHVsZS5leHBvcnRzLmlzUmdiID0gaXNSZ2I7XHJcbm1vZHVsZS5leHBvcnRzLmlzUmdiYSA9IGlzUmdiYTtcclxubW9kdWxlLmV4cG9ydHMuaGV4VG9SZ2IgPSBoZXhUb1JnYjtcclxubW9kdWxlLmV4cG9ydHMuYWRqdXN0Q29sb3JCcmlnaHRuZXNzID0gYWRqdXN0Q29sb3JCcmlnaHRuZXNzO1xyXG5tb2R1bGUuZXhwb3J0cy5yYW5kb21Db2xvciA9IHJhbmRvbUNvbG9yO1xyXG5tb2R1bGUuZXhwb3J0cy5yYW5kb21HcmFkaWVudCA9IHJhbmRvbUdyYWRpZW50O1xyXG5cblxuXG4vKioqKioqKioqKioqKioqKipcbiAqKiBXRUJQQUNLIEZPT1RFUlxuICoqIC4vc3JjL2NvbG9yVXRpbHMuanNcbiAqKiBtb2R1bGUgaWQgPSAzXG4gKiogbW9kdWxlIGNodW5rcyA9IDBcbiAqKi8iXSwic291cmNlUm9vdCI6IiJ9